/* C extension for array2hash.
This file in generated by Rubex::Compiler. Do not change!
File generation time: 2017-08-29 00:01:30 +0530.*/

#include <ruby.h>
#include <stdint.h>
#include <stdbool.h>
#include <ruby.h>

#define __rubex_INT2BOOL(arg) (arg ? Qtrue : Qfalse)


VALUE rb_cObject;
VALUE __rubex_rb_cls_Array2Hash;
static VALUE __rubex_rb_f_Array2Hash_convert (int argc,VALUE* argv,VALUE __rubex_arg_self);

VALUE __rubex_char2rubystr(char ch);
VALUE __rubex_char2rubystr(char ch)
{
  char s[2];
  s[0] = ch;
  s[1] = '\0';
  return rb_str_new2(s);
}


static VALUE __rubex_rb_f_Array2Hash_convert (int argc,VALUE* argv,VALUE __rubex_arg_self)
{
  VALUE __rubex_arg_a;
  long int __rubex_v_i;
  long int __rubex_v_j;
  VALUE __rubex_v_result;
  VALUE __rubex_temp_1;
  if (argc < 1)
  {
    rb_raise(rb_eArgError, "Need 1 args, not %d", argc);
  }

  __rubex_arg_a=argv[0];
  __rubex_v_i = NUM2LONG(rb_funcall(__rubex_arg_a, rb_intern("size"), 0, NULL));
  __rubex_v_j = 0;

  /* Rubex file location: /home/sameer/gitrepos/array2hash/ext/array2hash/array2hash.rubex:10 */
  __rubex_temp_1 = rb_hash_new();
  __rubex_v_result = __rubex_temp_1;
  __rubex_temp_1 = 0;
  __rubex_temp_1 = 0;
  while (( __rubex_v_j < __rubex_v_i ))
  {

    /* Rubex file location: /home/sameer/gitrepos/array2hash/ext/array2hash/array2hash.rubex:13 */
    rb_hash_aset(__rubex_v_result,RARRAY_AREF(__rubex_arg_a,__rubex_v_j),LONG2NUM(__rubex_v_j));

    /* Rubex file location: /home/sameer/gitrepos/array2hash/ext/array2hash/array2hash.rubex:14 */
    __rubex_v_j = ( __rubex_v_j + 1 );
  }


  /* Rubex file location: /home/sameer/gitrepos/array2hash/ext/array2hash/array2hash.rubex:17 */
  return __rubex_v_result;
}


void Init_array2hash ();
void Init_array2hash ()
{
  VALUE __rubex_rb_cls_Array2Hash;

  __rubex_rb_cls_Array2Hash = rb_define_class("Array2Hash", rb_cObject);

  rb_define_singleton_method(__rubex_rb_cls_Array2Hash ,"convert", __rubex_rb_f_Array2Hash_convert, -1);
}

